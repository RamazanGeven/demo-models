#X3D V3.2 utf8
PROFILE Interchange

# Fun with texture editing from KambiScript.
# Done as a demo of KambiScript capabilities to get/set image contents.
#
# Original texture image must have size 256x256 and must have 4 components
# for this demo to work nicely.
# Reasons:
# - Size 256x256 must be corresponding to IndexedFaceSet size,
#   to have 3D cursor moving in 3D space synchronized with texture pixel
#   coordinates (since we use cursor 3D position to take texture coordinates
#   to edit)
# - Components must be 4 because our simple script in KambiScript
#   assumes this (it's possible to write more universal program in
#   KambiScript, as you can query image_components(), but I was too lazy
#   to use this.)

Shape {
  appearance Appearance { texture DEF Tex PixelTexture { } }
  geometry IndexedFaceSet {
    solid FALSE
    coord Coordinate { point [ 0 0 0, 256 0 0, 256 256 0, 0 256 0 ] }
    coordIndex [ 0 1 2 3 ]
    texCoord TextureCoordinate { point [ 0 0, 1 0, 1 1, 0 1 ] }
  }
}

DEF CrossHair Transform {
  children Shape {
    appearance Appearance { material Material { diffuseColor 1 1 0 } }
    geometry Circle2D {
      radius 20
    }
  }
}

DEF Scr Script {
  inputOutput SFVec3f crosshair_pos 128 128 2
  outputOnly SFImage tex
  inputOnly SFInt32 action_key_press
  inputOnly SFString key_press

  # consts for key_press
  initializeOnly SFInt32 radius 20
  initializeOnly SFInt32 smooth_size 3

  # helper vars for key_press
  initializeOnly SFInt32 crosshair_x 0
  initializeOnly SFInt32 crosshair_y 0
  initializeOnly SFInt32 i 0
  initializeOnly SFInt32 j 0
  initializeOnly SFInt32 k 0
  initializeOnly SFInt32 l 0
  initializeOnly SFColor col 0 0 0
  initializeOnly SFImage new_image 0 0 1

  url [
"kambiscript:

function initialize(timestamp)
  { Dummy assignment to set initial CrossHair.translation }
  crosshair_pos := crosshair_pos;
  { Load initial texture. We had to use PixelTexture for this
    (ImageTexture doesn't give us SFImage field to work with),
    so loading it must be done from script. }
  tex := image_load('../../textures/test_texture.png')

function action_key_press(value, timestamp)
  if (value = ACTION_KEY_UP,
    vector_set(crosshair_pos, 1, vector_get(crosshair_pos, 1) + 3),
  if (value = ACTION_KEY_DOWN,
    vector_set(crosshair_pos, 1, vector_get(crosshair_pos, 1) - 3),
  if (value = ACTION_KEY_RIGHT,
    vector_set(crosshair_pos, 0, vector_get(crosshair_pos, 0) + 3),
  when (value = ACTION_KEY_LEFT,
    vector_set(crosshair_pos, 0, vector_get(crosshair_pos, 0) - 3)
  ))))

function key_press(value, timestamp)
  crosshair_x := round(vector_get(crosshair_pos, 0));
  crosshair_y := round(vector_get(crosshair_pos, 1));

  when (value = 'c',
    for (i, max(crosshair_x - radius, 0),
            min(crosshair_x + radius, image_width(tex) - 1),
      for (j, max(crosshair_y - radius, 0),
              min(crosshair_y + radius, image_height(tex) - 1),
        when( sqr(crosshair_x - i) +
              sqr(crosshair_y - j) < sqr(radius),
          image_set_color(tex, i, j,
            image_get_color(tex, i, j) - vector(0.2, 0.2, 0.2))))));

  when (value = 'C',
    for (i, max(crosshair_x - radius, 0),
            min(crosshair_x + radius, image_width(tex) - 1),
      for (j, max(crosshair_y - radius, 0),
              min(crosshair_y + radius, image_height(tex) - 1),
        when( sqr(crosshair_x - i) +
              sqr(crosshair_y - j) < sqr(radius),
          image_set_color(tex, i, j,
            image_get_color(tex, i, j) + vector(0.2, 0.2, 0.2))))));

  when (value = 'a',
    for (i, max(crosshair_x - radius, 0),
            min(crosshair_x + radius, image_width(tex) - 1),
      for (j, max(crosshair_y - radius, 0),
              min(crosshair_y + radius, image_height(tex) - 1),
        when( sqr(crosshair_x - i) +
              sqr(crosshair_y - j) < sqr(radius),
          image_set_alpha(tex, i, j,
            image_get_alpha(tex, i, j) - 0.2 )))));

  when (value = 'A',
    for (i, max(crosshair_x - radius, 0),
            min(crosshair_x + radius, image_width(tex) - 1),
      for (j, max(crosshair_y - radius, 0),
              min(crosshair_y + radius, image_height(tex) - 1),
        when( sqr(crosshair_x - i) +
              sqr(crosshair_y - j) < sqr(radius),
          image_set_alpha(tex, i, j,
            image_get_alpha(tex, i, j) + 0.2 )))));

  when (value = 's',
    { Smoothing changes new_image, taking pixels from original tex,
      this way we don't take partially smoothed colors into account when
      calculating new smoothed colors. }
    new_image := tex;
    for (i, max(crosshair_x - radius, 0),
            min(crosshair_x + radius, image_width(tex) - 1),
      for (j, max(crosshair_y - radius, 0),
              min(crosshair_y + radius, image_height(tex) - 1),
        when( sqr(crosshair_x - i) +
              sqr(crosshair_y - j) < sqr(radius),
          { smooth pixel (i, j) }
          col := vector(0, 0, 0);
          for (k, max(i - smooth_size , 0),
                  min(i + smooth_size, image_width(tex) - 1),
            for (l, max(j - smooth_size, 0),
                    min(j + smooth_size, image_height(tex) - 1),
              col := col + image_get_color(tex, k, l) / sqr(2*smooth_size+1)));
          image_set_color(new_image, i, j, col))));
    tex := new_image)
"
  ]
}

ROUTE Scr.crosshair_pos TO CrossHair.translation
ROUTE Scr.tex TO Tex.image

DEF K KeySensor { }
ROUTE K.actionKeyPress TO Scr.action_key_press
ROUTE K.keyPress TO Scr.key_press

# Camera settings "encoded" in the VRML declaration below :
# direction 0 0 -0.0199999995529651
# up 0 1 4.3711388286737929E-008
# gravityUp 0 1 0
Viewpoint {
  position 131.54255676269531 90.592330932617188 474.99456787109375
  orientation 0 0 1 0
}

NavigationInfo {
  type "NONE"
}

Transform {
  translation 128 -15 2
  children Shape {
    appearance Appearance { material Material { diffuseColor 1 1 0 } }
    geometry Text { string [
      "A toy in pure X3D using Script (in KambiScript language)"
      "to edit the texture (X3D SFImage field)."
      "Arrows move the cursor."
      "'c' / 'C' darken / lighten color."
      "'a' / 'A' decrease / increase alpha (opacity)."
      ]
      fontStyle FontStyle { size 20 justify "MIDDLE" }
    }
  }
}

Shape {
  appearance Appearance {
    texture PixelTexture { image 2 2 1 0 0xFF 0xFF 0
      textureProperties TextureProperties {
        magnificationFilter "NEAREST_PIXEL"
        minificationFilter "NEAREST_PIXEL"
      }
    }
    textureTransform TextureTransform {
      scale 20 20
    }
  }
  geometry IndexedFaceSet {
    solid FALSE
    coord Coordinate { point [ -128 0 -2, 384 0 -2, 384 384 -2, -128 384 -2 ] }
    coordIndex [ 0 1 2 3 ]
    texCoord TextureCoordinate { point [ 0 0, 1 0, 1 1, 0 1 ] }
  }
}
