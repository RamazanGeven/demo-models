#X3D V3.2 utf8
PROFILE Interchange

# ShaderTexture defining a nice smooth 3D noise in GLSL.
# The noise is infinite is all directions (so can be used e.g.
# to take 2D slice for water surface, with 3rd component from time).
# Uses white noise image texture underneath.
#
# Shows also the 2D (optimized) version of noise,
# and the (worse quality, but even faster) linear 2D noise.

# Camera settings "encoded" in the VRML declaration below :
# direction 0.3635934591293335 -0.4768730998039245 -0.800240933895111
# up -0.2291765660047531 0.7868427038192749 -0.5730183124542236
# gravityUp 0 1 0
Viewpoint {
  position 0.3367938995361328 3.9937033653259277 6.7564029693603516
  orientation -0.7869622111320495 -0.4050620794296264 0.4654194414615631 0.7302504777908325
}

Shape {
  appearance DEF App Appearance {
    material Material { }
    texture ImageTexture3D { url "textures/white_noise_3d.dds"
      textureProperties TextureProperties { minificationFilter "NEAREST_PIXEL" }
    }
  }
  geometry Box { }
}

Transform { translation 3 0 0 children
Shape {
  appearance DEF App Appearance {
    material Material { }
    texture ShaderTexture {
      defaultTexCoord "BOUNDS3D"
      effects DEF NoiseEffect1 Effect {
        language "GLSL"
        initializeOnly SFNode white_noise ImageTexture3D {
          url "textures/white_noise_3d.dds"
          repeatS TRUE
          repeatT TRUE
          repeatR TRUE
          textureProperties TextureProperties { minificationFilter "NEAREST_PIXEL" }
        }
        inputOnly SFTime time
        parts [
          DEF NoiseLibrary EffectPart {
            type "FRAGMENT"
            url "data:text/plain,

uniform sampler3D white_noise;
uniform float time;

const float white_noise_size = 8.0;

/* Linear-interpolated 2D noise.

   Make sure white_noise filtering is AVG_PIXEL for speed.
   Actually GPU does linear interpolation, and this is only a thin
   wrapper over texture3D call, to test that this is similar
   to noise_2d_cos */
float noise_2d_lin(const vec2 v)
{
  return texture3D(white_noise,
    vec3((v.xy + vec2(1.0)) / (white_noise_size * 2.0), 0.0)).r;
}

/* Cosine-interpolated 2D noise.

   Make sure white_noise filtering is NEAREST_PIXEL for speed,
   as it will be queried anyway only for complete pixel values.
   In fact, the standard bilinear filtering will smooth it
   unnecessarily, probably because we just do ''/ white_noise_size'',
   so we don't hit texel center (we should shift by
   0.5 / white_noise_size). */
float noise_2d_cos(const vec2 v)
{
  vec2 f = floor(v);
  vec2 c = ceil(v);

  vec2 c_fr = fract(v);
  c_fr = (cos(vec2(314.0 / 100.0) * (vec2(1.0) - c_fr)) + vec2(1.0)) / vec2(2.0);
  vec2 f_fr = vec2(1.0) - c_fr;

  return
    texture3D(white_noise, vec3(f.xy    , 0.0) / white_noise_size).r * f_fr.x * f_fr.y +
    texture3D(white_noise, vec3(c.x, f.y, 0.0) / white_noise_size).r * c_fr.x * f_fr.y +
    texture3D(white_noise, vec3(f.x, c.y, 0.0) / white_noise_size).r * f_fr.x * c_fr.y +
    texture3D(white_noise, vec3(c.xy    , 0.0) / white_noise_size).r * c_fr.x * c_fr.y;
}

/* Cosine-interpolated 3D noise.
   Just like 2D version. Since everything is on vectors,
   this is trivially similar to noise_2d_cos.
   (We still keep separate noise_2d_cos, as it may be faster.) */
float noise_3d_cos(const vec3 v)
{
  vec3 f = floor(v);
  vec3 c = ceil(v);

  vec3 c_fr = fract(v);
  c_fr = (cos(vec3(314.0 / 100.0) * (vec3(1.0) - c_fr)) + vec3(1.0)) / vec3(2.0);
  vec3 f_fr = vec3(1.0) - c_fr;

  return
    texture3D(white_noise, vec3(f.xyz        ) / white_noise_size).r * f_fr.x * f_fr.y * f_fr.z +
    texture3D(white_noise, vec3(c.x, f.y, f.z) / white_noise_size).r * c_fr.x * f_fr.y * f_fr.z +
    texture3D(white_noise, vec3(f.x, c.y, f.z) / white_noise_size).r * f_fr.x * c_fr.y * f_fr.z +
    texture3D(white_noise, vec3(c.xy    , f.z) / white_noise_size).r * c_fr.x * c_fr.y * f_fr.z +

    texture3D(white_noise, vec3(f.xy    , c.z) / white_noise_size).r * f_fr.x * f_fr.y * c_fr.z +
    texture3D(white_noise, vec3(c.x, f.y, c.z) / white_noise_size).r * c_fr.x * f_fr.y * c_fr.z +
    texture3D(white_noise, vec3(f.x, c.y, c.z) / white_noise_size).r * f_fr.x * c_fr.y * c_fr.z +
    texture3D(white_noise, vec3(c.xyz        ) / white_noise_size).r * c_fr.x * c_fr.y * c_fr.z;
}" }

EffectPart {
  type "FRAGMENT"
  url "data:text/plain,

void PLUG_texture_color(inout vec4 texture_color,
  in vec4 tex_coord)
{
  tex_coord.xyz += vec3(time / 2.0);
  texture_color.rgb = vec3(
    noise_3d_cos(tex_coord.xyz * 4.0) +
    noise_3d_cos(tex_coord.xyz * 8.0) / 2.0 +
    noise_3d_cos(tex_coord.xyz * 16.0) / 4.0
    ) / 3.0;
}" } ] } } }
  geometry Box { }
} }

Transform { translation 6 0 0 children
Shape {
  appearance DEF App Appearance {
    material Material { }
    texture ShaderTexture {
      defaultTexCoord "BOUNDS3D"
      effects DEF NoiseEffect2 Effect {
        language "GLSL"
        initializeOnly SFNode white_noise ImageTexture3D {
          url "textures/white_noise_3d.dds"
          repeatS TRUE
          repeatT TRUE
          repeatR TRUE
          textureProperties TextureProperties { minificationFilter "NEAREST_PIXEL" }
        }
        inputOnly SFTime time
        parts [
          USE NoiseLibrary
          EffectPart {
            type "FRAGMENT"
            url "data:text/plain,

void PLUG_texture_color(inout vec4 texture_color,
  in vec4 tex_coord)
{
  tex_coord.xyz += vec3(time / 2.0);
  texture_color.rgb = vec3(
    noise_2d_cos(tex_coord.xy * 4.0) +
    noise_2d_cos(tex_coord.xy * 8.0) / 2.0 +
    noise_2d_cos(tex_coord.xy * 16.0) / 4.0
    ) / 3.0;
}" } ] } } }
  geometry Box { }
} }

Transform { translation 9 0 0 children
Shape {
  appearance DEF App Appearance {
    material Material { }
    texture ShaderTexture {
      defaultTexCoord "BOUNDS3D"
      effects DEF NoiseEffect3 Effect {
        language "GLSL"
        initializeOnly SFNode white_noise ImageTexture3D {
          url "textures/white_noise_3d.dds"
          repeatS TRUE
          repeatT TRUE
          repeatR TRUE
  #        textureProperties TextureProperties { minificationFilter "AVG_PIXEL" }
        }
        inputOnly SFTime time
        parts [
          USE NoiseLibrary
          EffectPart {
            type "FRAGMENT"
            url "data:text/plain,

void PLUG_texture_color(inout vec4 texture_color,
  in vec4 tex_coord)
{
  tex_coord.xyz += vec3(time / 2.0);
  texture_color.rgb = vec3(
    noise_2d_lin(tex_coord.xy * 4.0) +
    noise_2d_lin(tex_coord.xy * 8.0) / 2.0 +
    noise_2d_lin(tex_coord.xy * 16.0) / 4.0
    ) / 3.0;
}" } ] } } }
  geometry Box { }
} }

# Time stuff -----------------------------------------------------------------

DEF Timer TimeSensor { loop TRUE }
ROUTE Timer.time TO NoiseEffect1.time
ROUTE Timer.time TO NoiseEffect2.time
ROUTE Timer.time TO NoiseEffect3.time

EXTERNPROTO KambiNavigationInfo [
  inputOnly   SFBool   set_bind
  inputOutput MFFloat  avatarSize
  inputOutput SFBool   headlight
  inputOutput SFFloat  speed
  inputOutput MFString type
  inputOutput SFFloat  visibilityLimit
  outputOnly  SFBool   isBound
  initializeOnly  SFBool   timeOriginAtLoad
] [ "urn:vrmlengine.sourceforge.net:node:KambiNavigationInfo",
    "http://vrmlengine.sourceforge.net/fallback_prototypes.x3dv#KambiNavigationInfo"
]

KambiNavigationInfo {
  headlight TRUE
  type ["EXAMINE", "ANY"]
  timeOriginAtLoad TRUE
}
